//============================================================================
// Name        : main.cpp
// Author      : Zikai Alex Wen
// Version     :
// Copyright   :
// Description : Launch Run File
//============================================================================

#include "src/dealer.h"
#include "src/user.h"
#include <boost/shared_ptr.hpp>

typedef boost::shared_ptr<DEALER> dealerPtr;

int main(int argc, char *argv[]) {
	using namespace std;
	//dealerPtr testo (new DEALER(argv[1])); //the path of database
	DEALER* testo = new DEALER(argv[1]);
	USER* teste = new USER(argv[2]);	//the public key
	testo->outSource(argv[2],argv[3]);
	teste->readPathsFile(argv[3]);	//stores path
	teste->getNewPuzzle(argv[4]);	//puzzle id
	teste->releaseTicket(argv[5]);	//ticket path
	/*TICKET* testa = new TICKET;
	if (testa == nullptr) {
		cout << "ticket not ready" << endl;
		return -1;
	}*/
	/*int it_index = -1;
	cout << "pubkey: " << COMMON::stringToHex(testa->pubkey) << endl;
	cout << "seed: " << COMMON::stringToHex(testa->seed) << endl;
	for (auto it : testa->mkproofs) {
		cout << "item: ";
		COMMON::printHex((const uchar*)it->returnLeafPt(),LEAF_SIZE);
		cout << " and its hash siblings are: " << endl;
		it_index = 0;
		for (auto jt : it->returnSiblings()) {
			cout << "layer " << (it_index++) << " ";
			COMMON::printHex(jt,HASH_SIZE);
		}
	}*/
	//delete testa;
	delete teste;
	delete testo;
	return 0;
}
//// main.cpp 08.30.14
//	size_t yo = 100;
	int yo = -100;
//	unsigned char* ptr = reinterpret_cast<unsigned char *>(&yo);
	char* ptr = reinterpret_cast<char *>(&yo);
	for(int i = 0; i < sizeof(int); i ++){
		printf("%02x",ptr[i]);
	}
	printf("\n");
//// Reinterpret cast 08.27
//	unsigned char test[5][LEAF_SIZE];
	/*leaf test[5];
	memcpy(test[0], "123", LEAF_SIZE); // Should be LEAF_SIZE otherwise the rest of char array won't be null
	memcpy(test[1], "234", LEAF_SIZE);
	memcpy(test[2], "567", LEAF_SIZE);
	memcpy(test[3], "567", LEAF_SIZE);
	memcpy(test[4], "567", LEAF_SIZE);*/
//	memcpy(test[2], "123" , 4);
//	MERKLE testo(test, 5);
//	testo.buildPath(0);

	/*zk_leaf t;
	std::vector<zk_leaf> test2;
	for (int i = 0; i < 5; i++) {
		t.assign(test[i], LEAF_SIZE);
		test2.push_back(t);
	}
	MERKLE testo2(test2);
	testo2.buildPath(0);*/
////// main file test code 08.22

/*	FILE *inputs;
	inputs = fopen(filenamePt, "r");
	if (inputs == NULL) {
		printf("Cannot open file @ DEALER 1st constructor. \n");
		exit(FILE_ERR);
	}
	while(fread() > 0){
		//TODO: Assure it's safe if the final segment is less than LEAF_SIZE

	}*/
/////// c file operator in dealer class 08.22
//TODO- 1. add copyright and software license

#ifndef PERMACN_MERKLE_H //for avoid multi-inclusions of header files
#define PERMACN_MERKLE_H

#include <stdint.h>
#include <stdlib.h>

#include "common.h"
#define LEAF_SIZE 1024
typedef unsigned char digest[20];

struct node {
    digest dgst;

    node *leftPt = nullptr;
    node *rightPt = nullptr;
};	// of a Merkle tree

struct leaf {
	unsigned char data[LEAF_SIZE];
	node *processedPt = nullptr;
};	// link the data to its leaf among all

struct path {
    leaf item;
    digest *siblings;
};	// to validate the integrity of an item

class MERKLE {
private:
    int height;
    node *rootPt;
    leaf *segments;

public:
    inline node *layer(int k);
    digest hashLeaf();

};

#endif
/// merkle.h v0.1
	leaf seg[10];
	std::cout << "bytes of whole array (10440) " << sizeof(seg) << std::endl;
	std::cout << "single element bytes (1044) " << sizeof(*seg) << std::endl;
	std::cout << "size of arrays (10) " << sizeof(seg) / sizeof(*seg) << std::endl;
/// test sizeof function
	using namespace std;
	leaf test[3];
	memcpy(test[0].data, "123" , sizeof("123"));
	SHA1(test[0].data,sizeof(test[0].data),test[0].hash);
	memcpy(test[1].data, "456" , sizeof("456"));
	SHA1(test[1].data,sizeof(test[1].data),test[1].hash);
	memcpy(test[2].data, "678" , sizeof("678"));
	SHA1(test[2].data,sizeof(test[2].data),test[2].hash);
	MERKLE testo(test,sizeof(test)/sizeof(*test));
	cout << testo.returnHeight() << endl;
/// test Memo allocation
//TODO- 1. add copyright and software license

#ifndef PERMACN_MERKLE_H //for avoid multi-inclusions of header files
#define PERMACN_MERKLE_H

#include <cstdint>
#include <cstdlib>

#include "common.h"

#define LEAF_SIZE 1024
typedef unsigned char digest[20];


struct leaf {
	unsigned char data[LEAF_SIZE];
	digest hash;
};	// data and its hash value

struct path {
    leaf item;
    digest *siblings;
};	// to validate the integrity of an item

class MERKLE {
private:
    int now_layer, next_layer, height;
    size_t num_leaves;
    leaf *segments;
    digest **arrays;
public:
    MERKLE(unsigned char segments[][LEAF_SIZE], size_t num_segs);
    int returnHeight();
};

#endif
/// merkle.h 07.30
#include "merkle.h"

#include <cmath>
#include <cstdio>
#include <cstring>
#include <stdexcept>
#include <iostream>
#include <openssl/sha.h>


// Internal implementation code
namespace {

/* printHex - to print the unchar array in Hex form
 * Input - unchar array; Outuput - void; Affect - None
 */
void printHex(const unsigned char *d) {
    for (int i = 0; i < 20; i++) printf("%02x", d[i]);
    printf("\n");
}
// Internal Merkle Tree implmentation
namespace merkle {

digest hashTwoDigests(digest left, digest right){
	unsigned char tmp_char[40];
	// TODO - unwrap self-defined struct and set the digest as a long array
}

}	// namespace merkle

}	// namespace

/* Merkle tree 1st constructor
 * Input - the segments of entire file (segment is in fixed length) & their size;
 * Ouput - void; Affect - initialise the private data source
 */
MERKLE::MERKLE(unsigned char segmts[][LEAF_SIZE], size_t num_segs){
	using namespace std;
	height = ceil(log2(num_segs)); // excludes leaves layer

	// Arrays memory allocation
	try{
		arrays = new digest*[height];
	}catch (bad_alloc& err){
		cerr << err.what() <<
				" @ MERKLE 1st constructor for [arrays**]." << endl;
	}
	size_t num_elem = 1;
	now_layer = 0;
	next_layer = 0;
	while(now_layer < height){
		// Coutest H arrays
		// cout << "now layer: " << now_layer << " has " << num_elem << " element(s). " << endl;
		try{
			arrays[now_layer++] = new digest[num_elem];
			num_elem = num_elem << 1;
		}catch (bad_alloc& err){
			cerr << err.what() <<
					" @ MERKLE 1st constructor for [arrays*]." << endl;
		}
	}
	// The status after breaking the while loop is the leaf layer

	// Process leaves
	try{
		segments = new leaf[num_elem]; // full binary tree
	}catch (bad_alloc& err){
		cerr << err.what() <<
				" @ MERKLE 1st constructor for [segments*]." << endl;
	}

	for(size_t i = 0; i < num_segs; i++){
		memcpy(segments[i].data,segmts[i],LEAF_SIZE);
		SHA1(segmts[i],LEAF_SIZE,segments[i].hash);
		// Coutest memcpy
		/*cout << "No. " << i << ": " << segments[i].data  << endl;
		cout << "And its hash value: ";
		printHex(segments[i].hash);*/
		//printHex(segments[i].data);
	}

	// Fill the leaves into a full binary tree
	num_leaves = num_segs;
	while(num_leaves < num_elem){
		// TODO - should be a LEAF_SIZE random bits
		memset(segments[num_leaves].data,0,LEAF_SIZE);
		SHA1(segments[num_leaves].data,LEAF_SIZE,segments[num_leaves].hash);
		num_leaves++;
	}

	// Coutest all leaves
	for(size_t i = 0; i < num_elem; i++){
		cout << "No. " << i << ": " << segments[i].data  << endl;
		cout << "And its hash value: ";
		printHex(segments[i].hash);
		//printHex(segments[i].data);
	}

	// Hash children digests


}

/* returnHeight - to return the height of this Merkle tree
 * ! Excludes the leaf layer
 */
int MERKLE::returnHeight(){
	return height;
}
/// merkle.cpp 07.30

/*
 * Assign a std::array with a c-style array
 * Input - c-srtring array head pointer, the length of array
 * Return - a std::array
 */
template<typename T, std::size_t N>
std::array<T, N> assignStdArray(T ca, size_t len) {
	std::array<T, N> a;
	size_t bound = std::min(N, len);
	for(size_t i = 0; i < bound; i++){
		//a[i] = ca[i];
	}
	return a;
}
/// Template method 08.20